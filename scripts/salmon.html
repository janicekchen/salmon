<! DOCTYPE html>
<html>
	<head>
		<script src ='https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js'></script>
		<script src = "../d3-simple-slider/d3-simple-slider.min.js"></script>

		<style>
		
			body {
				margin: 0;
			}

			.tooltip {
				font-family: sans-serif;
				font-weight: 100;
				font-size: 12;
			}

	
		</style>
	</head>
	<body>
		<div id = "slider" style = "position: absolute; height: 0px; width: 100%;"></div>
		<div id = "map"></div>
		<script type = 'text/javascript'>
			const world = "https://gist.githubusercontent.com/janicekchen/de49f6bd754b6955ca27e2dddaf13218/raw/f805b1583af0e0500e1a4884bb0dd40834019aa8/worldmap.json";

			const netSalmon = "https://gist.githubusercontent.com/janicekchen/de49f6bd754b6955ca27e2dddaf13218/raw/11512b328999d93a47662726685b43e93fe82007/net_all.csv";

			const states = "https://gist.githubusercontent.com/janicekchen/de49f6bd754b6955ca27e2dddaf13218/raw/d5c58da63f9a8eeb10f5990e60b029b9bd3356f4/us.json";

			const provinces = "https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/canada.geojson"
			
			var windowHeight = window.innerHeight;
			var windowWidth = window.innerWidth;
			var lastX = 0,
				lastY= 0,
				scale = 800,
			    origin = {
			    	x: 110, 
			    	y: -50
			    };


			var svg = d3.select("#map")
			            .append("svg")
			            .attr("height", windowHeight)
			            .attr("width", windowWidth)
			            .style("background-color", "#ffff0");

			var projection = d3.geoOrthographic()
			                   	.rotate([origin.x, origin.y])
			               
			                   .translate([windowWidth / 2, windowHeight / 2	])
			                   .scale(scale);

			var path = d3.geoPath().projection(projection);

			var graticule = d3.geoGraticule();
			var globe = svg.append("g");
			var grats = svg.append("g");
			var countries = svg.append("g");
			var states_grp = svg.append("g");
			var provinces_grp = svg.append("g");
			var countries = svg.append("g");
			var salmonF = svg.append("g");

			// drawing globe outline
			globe.append("path")
				     .datum({type: "Sphere"})
				     .attr("d", path)
				     .attr("fill", "#c5dcde")
				     .attr("stroke", "black");

			d3.json(world).then(function(data) {
		
				countries.selectAll("path")
				   .data(data.features)
				   .enter()
				   .append("path")
				   .attr("d", path)
				   .style("fill", "white")
				   .style("stroke", "#013f45")
				   .style("stroke-width", "0.5");

				
				grats.selectAll("path")
				     .data(graticule.lines())
				     .enter()
				     .append("path")
				     .attr("d", path)
				     .attr("class", "hi")
				     .attr("stroke-width", ".3px")
				     .attr("fill", "none")
				     .attr("stroke", "white")
				     .attr("stroke-opacity", ".5");

			});

			d3.json(states).then(function(data) {
				states_grp.selectAll("path")
				      .data(data.features)
				      .enter()
				      .append("path")
				      .attr("d", path)
				      .style("fill", "none")
				      .style("stroke", "#013f45")
				      .attr("stroke-width", "0.1")
			})

			d3.json(provinces).then(function(data) {
				provinces_grp.selectAll("path")
				      .data(data.features)
				      .enter()
				      .append("path")
				      .attr("d", path)
				      .style("fill", "white")
				      .style("stroke", "#013f45")
				      .attr("stroke-width", "0.1")
			})

			function drawSalmon(year) {
				d3.csv(netSalmon).then(function(data) {

					var filtData = data.filter(function(d) {
						return d.year == year;
					})

					var link = []
					filtData.forEach(function(row) {
						source = [+row.state_lon, +row.state_lat]
						target = [+row.city_lon, +row.city_lat]
						topush = {type: "Feature",
								  geometry: {
								  	type: "LineString", 
								  	coordinates: [source, target]
								  },
								  "properties": {
								  	"exp_quant": row.exp_quant,
								  	"imp_quant": row.imp_quant,
								  	"exp_value": row.exp_value,
								  	"imp_value": row.imp_value,
								  	"state": row.state,
								  	"city": row.city
								  }
								}

						link.push(topush)
					})

					var tooltip = d3.select("body")
					    .append("div")
					    .style("position", "absolute")
					    .style("opacity", 0)
					    .attr("class", "tooltip")
					    .style("background-color", "white")
					    .style("border", "solid")
					    .style("border-width", "1px")
					    .style("border-radius", "2px")
					    .style("padding", "10px")

					var mouseover = function(d) {
					    tooltip
					      .style("opacity", 1)
					  }

					var mousemove = function(d) {
					   tooltip
					     .html("<strong>" + d.properties.city + " -- " + d.properties.state + "<br>Export quantity | value: </strong>" + d3.format(",.0f")(d.properties.exp_quant) + " | " + d3.format("$,.0f")(d.properties.exp_value) + "<strong><br> Import quantity | value:</strong> " + d3.format(",.0f")(d.properties.imp_quant) + " | " + d3.format("$,.0f")(d.properties.imp_value))
					     .style("left", (d3.mouse(this)[0]+90) + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
					     .style("top", (d3.mouse(this)[1]) + "px")
					 }

					 // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
					 var mouseleave = function(d) {
					   tooltip
					     .transition()
					     .duration(200)
					     .style("opacity", 0)
					 };

					var flows = salmonF.selectAll("path")
					                   .data(link);

					flows.enter()
					     .append("path")
					     .merge(flows)
					      .attr("d", function(d) {
					      	return (path(d.geometry))
					      })
					      .style("fill", "none")
					      .style("stroke", function(d) {
					      	var net = d.properties.exp_quant - d.properties.imp_quant;
					      	if (net > 0) { return "#26694d"}
					      	else { return "#9e2613"}
					      })
					      .style("stroke-width", function(d) {
					      	var net = d.properties.exp_quant - d.properties.imp_quant;
					      	return Math.abs(net) / 500000;
					      })
					      .on("mouseover", mouseover)
					      .on("mousemove", mousemove)
					      .on("mouseleave", mouseleave)



				})
				
			}
				
			drawSalmon(2020)



			// drag & zoom
			/*const initialScale = projection.scale()
			const sensitivity = 75;
			const drag = d3.drag().on('drag', () => {
				const rotate = projection.rotate()
				const k = sensitivity / projection.scale()
				projection.rotate([
					rotate[0] + d3.event.dx * k,
					rotate[1] - d3.event.dy * k])
				path = d3.geoPath().projection(projection)
				svg.selectAll("path").attr("d", path)

			})

			const zoom = d3.zoom()
			  .on('zoom', (transform) => {
			  	if(d3.event.sourceEvent.wheelDelta) {

			  	} else {

			  	}
				if (d3.event.transform.k > 0.3) {
					projection.scale(initialScale * d3.event.transform.k)
					path = d3.geoPath().projection(projection)
					svg.selectAll("path").attr("d", path).attr('transform', d3.event.transform);
				} 
				else {
					d3.event.transform.k = 0.3;
				}  

				console.log(d3.event.transform)
			})*/

			var λ = d3.scaleLinear()
			  .domain([-windowWidth, windowWidth])
			  .range([-180, 180])

			var φ = d3.scaleLinear()
			  .domain([-windowHeight, windowHeight])
			  .range([90, -90]);

			function zoomed() {
			   var transform = d3.event.transform;
			   var r = {
			     x: λ(transform.x),
			     y: φ(transform.y)
			   };
			   var k = Math.sqrt(100 / projection.scale());
			   if (d3.event.sourceEvent.wheelDelta) {
			     projection.scale(scale * transform.k)
			     transform.x = lastX;
			     transform.y = lastY;
			   } else {
			     projection.rotate([origin.x + r.x, origin.y + r.y]);
			     lastX = transform.x;
			     lastY = transform.y;
			   }
			   svg.selectAll("path").attr("d", path)
			 };

			 function wheeled() {
			 	console.log("hey")
			 	var transform = d3.event.transform;
			 	if (d3.event.ctrlKey) {
			 		projection.scale(scale * transform.k)
			 		transform.x = lastX;
			 		transform.y = lastY;
			 	}
			 }
			 const zoom = d3.zoom().on('zoom', zoomed);


			svg.call(zoom);


			var slider = d3.sliderHorizontal()
			               .min(1990)
			               .max(2020)
			               .step(1)
			               .width(windowWidth - 100)
			               .default(2020)
			               .tickFormat(d3.format(".0f"))
			               .displayValue(true)
			               .on("drag", val => {drawSalmon(val)})

			var sliderSVG = d3.select("#slider")
			  .append('svg')

			sliderSVG.attr('width', windowWidth)
			  .attr('height', 70)
			  .style("background-color", "rgba(255, 255, 255, 0.8")
			  .append('g')
			  .attr('transform', 'translate(50,20)')
			  .call(slider);



		</script>
	</body>
</html